# Delve

Delve是官方扶持的源码级别调试器，能满足日常开发需求。

详细信息请参考[官方文档](https://github.com/go-delve/delve)，本文记录一些基本操作。

* 编译并调试，使用 `dlv debug`。
* 已编译程序，使用 `dlv exec`。
* 已运行程序，使用 `dlv attach`。
* 检查 core dump, 使用 `dlv core`。
* 服务器模式(debug server) 以 `--headless` 启动，客户端 `dlv connect` 接入。

&nbsp;

**调试模式：**

* 自动以 `-gcflags all=-N -l` 方式编译。
* 如想 `go build` 传递参数，使用 `--build-flags`。
* 支持 `runtime.Breakpoint()` 设置断点。

&nbsp;

```go
package main

func add(x, y int) int {
    z := x + y
    return z
}

func main() {
    println(add(1, 2))
}
```

&nbsp;

## 位置

相关位置需要一个位置参数(linespec)。

* `l, ls, list`：查看源码。 </br>

* `<filename>:<line>`：源文件名和行号。
* `<line>`：当前源文件行号。
* `<func>:<line>`：函数内第几行。(定义为起点0)

&nbsp;

* `+<offset>, -<offset>`：基于当前行的偏移量。
* `*<address>`：内存地址。
* `/regex/`：正则表达式匹配的函数。

&nbsp;

```bash
(dlv) b main.add:2
Breakpoint 1 set at 0x45f0ef for main.add() ./main.go:5
(dlv) c
> main.add() ./main.go:5 (hits goroutine(1):1 total:1) (PC: 0x45f0ef)
     1: package main
     2:
     3: func add(x, y int) int {
     4:     z := x + y
=>   5:     return z
     6: }
     7:
     8: func main() {
     9:     println(add(1, 2))
    10: }
```

&nbsp;

## 断点

* `b, break`：设置断点。
* `bp, breakpoints`：显示所有已设置断点。

&nbsp;

* `toggle`：开关断点。
* `clear, clearall`：删除指定或全部断点。

&nbsp;

* `cond, condtion`：设置断点命中条件。
* `on`：设置断点命中执行命令。
* `t, tracepoint`：设置跟踪点。

&nbsp;

```bash
(dlv) b main.add:2
Breakpoint 1 set at 0x45f0ef for main.add() ./main.go:5

(dlv) bp
Breakpoint 1 (enabled) at 0x45f0ef for main.add() ./main.go:5 (0)

(dlv) on 1 locals
(dlv) cond 1 x == 1
(dlv) bp
Breakpoint 1 (enabled) at 0x45f0ef for main.add() ./main.go:5 (0)
    cond x == 1
    locals

(dlv) c
> main.add() ./main.go:5 (hits goroutine(1):1 total:1) (PC: 0x45f0ef)
    z: 3
     1: package main
     2:
     3: func add(x, y int) int {
     4:     z := x + y
=>   5:     return z
     6: }
     7:
     8: func main() {
     9:     println(add(1, 2))
    10: }
```

```bash
(dlv) clear 1
Breakpoint 1 cleared at 0x45f0ef for main.add() ./main.go:5

(dlv) clearall
```

&nbsp;

特殊“断点”(tracepoint)，它不会终端程序执行，仅在命令时(hit) 输出信息。
可用来跟踪代码是否被执行。

```bash
(dlv) t abc main.add
Tracepoint abc set at 0x45f0c0 for main.add() ./main.go:3
```

&nbsp;

可在汇编指令级别设置断点。

```bash
(dlv) b *0x45f120
Breakpoint 2 set at 0x45f120 for main.main() ./main.go:9
(dlv) c
> main.main() ./main.go:9 (hits goroutine(1):1 total:1) (PC: 0x45f120)
     4:     z := x + y
     5:     return z
     6: }
     7:
     8: func main() {
=>   9:     println(add(1, 2))
    10: }
```

&nbsp;

## 运行

调试器启动时，会在`_rt0_amd64_linux`处停住，并非`main.main`用户代码入口。

* `c, continue`：继续运行，直到某些断点被命中。
* `n, next`：下一源码行(或指定行数)。
* `s, step`：下一行，进入所调用函数内部。

&nbsp;

* `so, stepout`：执行，直到跳出当前函数。
* `si, step-instruction`：下一条命令(汇编)。

&nbsp;

* `r, restart`：重启。
* `rebuild`：重新编译，重启调试。
* `q, exit`：退出。

&nbsp;

> 不输入命令，直接回车，表示执行上一条命令。连续单行执行时，很方便。

&nbsp;

## 堆栈

调用堆栈(call stack)由函数栈帧(stack frame)组成。

* `bt, stack`：显示整个调用堆栈。
* `frame`：设置缺省栈帧。
* `up, down`：调整缺省堆栈。

&nbsp;

> 调整缺省栈帧后， bt列表里没有相关提示。可用list输出源码，开头会显示栈帧编号。

```bash
(dlv) b main.add
(dlv) c

(dlv) bt
0  0x000000000045f0c0 in main.add
   at ./main.go:3
1  0x000000000045f125 in main.main
   at ./main.go:9
2  0x00000000004358b8 in runtime.main
   at /usr/local/go/src/runtime/proc.go:250
3  0x000000000045c0c1 in runtime.goexit
   at /usr/local/go/src/runtime/asm_amd64.s:1594
```

可在某个具体的goroutine上执行调试命令。

* `gr, goroutine`：显示或修改默认G。
* `grs, goroutines`：列出所有G。

&nbsp;

* `tr, thread`：切换线程。
* `threads`：列出所有线程。

&nbsp;

```bash
(dlv) gr
Thread 263 at ./main.go:3
Goroutine 1:
    Runtime: ./main.go:3 main.add (0x45f0c0)
    User: ./main.go:3 main.add (0x45f0c0)
    Go: <autogenerated>:1 runtime.newproc (0x45e585)
    Start: /usr/local/go/src/runtime/proc.go:145 runtime.main (0x4356e0)
    
(dlv) grs
* Goroutine 1 - User: ./main.go:3 main.add (0x45f0c0) (thread 263)
  Goroutine 2 - User: /usr/local/go/src/runtime/proc.go:364 runtime.gopark (0x435cdd) [force gc (idle)]
  Goroutine 17 - User: /usr/local/go/src/runtime/proc.go:364 runtime.gopark (0x435cdd) [GC sweep wait]
  Goroutine 18 - User: /usr/local/go/src/runtime/proc.go:364 runtime.gopark (0x435cdd) [GC scavenge wait]
[4 goroutines]

(dlv) gr 1 bt
0  0x000000000045f0c0 in main.add
   at ./main.go:3
1  0x000000000045f125 in main.main
   at ./main.go:9
2  0x00000000004358b8 in runtime.main
   at /usr/local/go/src/runtime/proc.go:250
3  0x000000000045c0c1 in runtime.goexit
   at /usr/local/go/src/runtime/asm_amd64.s:1594
```

```bash
(dlv) grs -g        # 查看 goroutine 创建位置
* Goroutine 1 - Go: <autogenerated>:1 runtime.newproc (0x45e585) (thread 263)
  Goroutine 2 - Go: /usr/local/go/src/runtime/proc.go:290 runtime.init.6 (0x435a45) [force gc (idle)]
  Goroutine 17 - Go: /usr/local/go/src/runtime/mgc.go:178 runtime.gcenable (0x41550b) [GC sweep wait]
  Goroutine 18 - Go: /usr/local/go/src/runtime/mgc.go:179 runtime.gcenable (0x41554a) [GC scavenge wait]
[4 goroutines]
```

&nbsp;

## 查看

命中断点后，通过输出一系列相关信息来确定我们要做什么。

* `args`：函数参数。
* `locals`：局部变量。
* `vars`：全局变量。
* `whatis`：类型信息。
* `p, print`：输出表达式值。
* `display`：每次程序中断时，输出表达式结果。
* `set`：修改变量值。
* `regs`：输出寄存器。
* `x, examinemem`：输出内存值。

&nbsp;

## 测试

可以但愿测试为调试入口。

> 调试器 `--` 分隔目标程序参数，可用 `test.run` 指定具体的目标函数。

```bash
$ dlv test -- -test.run "TestB"

(dlv) funcs TestB
test.TestB

(dlv) b test.TestB
```

&nbsp;

## 其他

文档某些命令似乎被移除。

* `call`：调用函数(实验)。
* `disass, disassemble`：反汇编。
* `funcs`：函数列表(不确定函数全名时，可查)。
* `types`：类型列表。
