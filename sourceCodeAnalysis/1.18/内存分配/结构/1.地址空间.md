# 地址空间

通过“预留”方式获取连续地址空间，以便后续合并内存块，减少碎片。

&nbsp;

## 基本概念

* arena: 预留地址空间，用户对象在此范围内分配。
* bitmap: 基于类型信息，以位图标记对象指针。(GC)
* spans: 反查内存归属的mspan管理对象。

> 从1.11开始，使用稀疏堆(sparse heap)替代原先超大地址空间的做法。消除了512GB限制，最大可以到256TB。
>
> 相比1.10在初始化(mallocinit)阶段预保留(sysReserve)，当前只在分配(sysAlloc)阶段保留，默认只记录地址，如此让进程初始VIRT小很多。

```go
// mheap.go

type mheap struct {
    arenas [1 << arenaL1Bits]*[1 << arenaL2Bits]*heapArena
    arenaHints *arenaHint
}

type heapArena struct {
    // bitmap stores the pointer/scalar bitmap for the words in
    // this arena. See mbitmap.go for a description. 
    bitmap [heapArenaBitmapBytes]byte
    
    // spans maps from virtual address page ID within this arena to *mspan.
    spans [pagesPerArena]*mspan
}

type arenaHint struct {
    addr uintptr
    down bool
    next *arenaHint
}
```

```go
+--------------+
| heap         |              可分配地址
+--------------+            +-----------+            +-----------+
|   arenaHints | ---------> | arenaHint | ----//---> | arenaHint |
+--------------+            +-----------+            +-----------+
|   arenas[L1] | ----+
+--------------+     |      +----------------+
                     +----> | *heapArena[L2] |         已分配区域
                     |      +----------------+       +-----------+
                     |      | ...            | ----> | heapArena |
                     |      +-------//-------+       +-----------+
                     |      | ...            |       |   bitmap  |  指针位图
                     |      +----------------+       +-----------+
                     |                               |   spans   |  反查表
                     +----> ...                      +-----------+
```

&nbsp;

## 初始化

`schedinit`调用`mallocinit`进行内存分配器初始化。

```go
// mheap.go

var mheap_ mheap
```

```go
// malloc.go

func mallocinit() {

    // 初始化堆。
    mheap_.init()
    mcache0 = allocmcache()

    // 预留地址空间。
    if goarch.PtrSize == 8 {  // 64-bit
    
        // On a 64-bit machine, we pick the following hints
        // because:
        //
        // 1. Starting from the middle of the address space
        // makes it easier to grow out a contiguous range
        // without running in to some other mapping.
        //
        // 2. This makes Go heap addresses more easily
        // recognizable when debugging.
        //
        // 3. Stack scanning in gccgo is still conservative,
        // so it's important that addresses be distinguishable
        // from other data.
        //
        // Starting at 0x00c0 means that the valid memory addresses
        // will begin 0x00c0, 0x00c1, ...
    
        for i := 0x7f; i >= 0; i-- {
            var p uintptr

            switch {
            case GOARCH == "arm64":
                p = uintptr(i)<<40 | uintptrMask&(0x0040<<32)
            default:
                p = uintptr(i)<<40 | uintptrMask&(0x00c0<<32)
            }

            // 初始地址，保存到 mheap.arenaHints 链表。
            hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())
            hint.addr = p
            hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
        }
    } else {  // 32-bit
        ...
        mheap_.arena.init(uintptr(a), size, false)
        ...
    }
}
```

可以看出，初始化时记录了很多段地址空间，依次存储在链表内。

> 仅记录，而非提前预留(sysReserved)，这有助于减少启动时虚拟内存数值。

```go
// malloc.go

553         hint := (*arenaHint)(mheap_.arenaHintAlloc.alloc())
554         hint.addr = p
555         hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
556     }
557 } else {
```

```bash
$ gdb test

(gdb) b malloc.go:555
Breakpoint 1 at 0x40ccaa: file /usr/local/go/src/runtime/malloc.go, line 555.

(gdb) r
Breakpoint 1, runtime.mallocinit () at /usr/local/go/src/runtime/malloc.go:555
555             hint.next, mheap_.arenaHints = mheap_.arenaHints, hint


(gdb) display/x *hint

1: /x *hint = {
  addr = 0x7fc000000000,    ; 0x7fc
  down = 0x0,
  next = 0x0
}

(gdb) c

1: /x *hint = {
  addr = 0x7ec000000000,    ; 0x7ec
  down = 0x0,
  next = 0x0
}

(gdb) c

1: /x *hint = {
  addr = 0x7dc000000000,    ; 0x7dc
  down = 0x0,
  next = 0x0
}
```

&nbsp;

### 可分配地址

每个`arenaHint`记录可分配起始地址(累进)及分配方向(向高位或地位)。如分配失败，则尝试从链表取下一个`areanaHint`重试，或由操作系统提供随机地址。

```go
// mheap.go

type arenaHint struct {
    addr uintptr
    down bool
    next *arenaHint
}
```

调用 `sysAlloc` 分配内存时，先获取有效地址。

```go
// malloc.go

// sysAlloc allocates heap arena space for at least n bytes. The
// returned pointer is always heapArenaBytes-aligned and backed by
// h.arenas metadata. 
//
// sysAlloc returns a memory region in the Reserved state. This region must
// be transitioned to Prepared and then Ready before use.

func (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {

    n = alignUp(n, heapArenaBytes)

    // 用于 32-bit 分配。heap.arena 在 mallocinit 32-bit 块内初始化。
    // 如果当前 64-bit，那么 h.arena.alloc 返回 nil。    
    v = h.arena.alloc(n, heapArenaBytes, &memstats.heap_sys)
    if v != nil {
        size = n
        goto mapped
    }

    // 尝试用 hint.addr 地址。
    for h.arenaHints != nil {

        hint := h.arenaHints
        p := hint.addr

        // 如果向低位分配，那么需要调整起始地址。
        if hint.down {
            p -= n
        }

        // 保留该地址段。
        if p+n < p {
            // We can't use this, so don't ask.
            v = nil
        } else if arenaIndex(p+n-1) >= 1<<arenaBits {
            // Outside addressable heap. Can't use.
            v = nil
        } else {
            v = sysReserve(unsafe.Pointer(p), n)
        }

        // 如果保留成功，更新 hint 数据。
        if p == uintptr(v) {
            // Success. Update the hint.
            if !hint.down {
                p += n
            }
            hint.addr = p
            size = n
            break
        }

        // Failed. Discard this hint and try the next.
        if v != nil {
            sysFree(v, n, nil)
        }

        // 失败！尝试下一链表项。并释放当前 hint 内存。
        h.arenaHints = hint.next
        h.arenaHintAlloc.free(unsafe.Pointer(hint))
    }

    // 尝试整个链表后依旧失败，则向操作系统申请。
    if size == 0 {

        // All of the hints failed, so we'll take any
        // (sufficiently aligned) address the kernel will give
        // us.
        v, size = sysReserveAligned(nil, n, heapArenaBytes)
        if v == nil {
            return nil, 0
        }

        // 操作系统返回一个可用地址。
        // 将该地址左右两个区域存储到链表内，以供下次使用。

        // 左侧。
        hint := (*arenaHint)(h.arenaHintAlloc.alloc())
        hint.addr, hint.down = uintptr(v), true
        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint

        // 右侧。（去掉本次分配）
        hint = (*arenaHint)(h.arenaHintAlloc.alloc())
        hint.addr = uintptr(v) + size
        hint.next, mheap_.arenaHints = mheap_.arenaHints, hint
    }

mapped:
    return
}
```
