# 流程

首先，调用 `startCycle` 开始新周期。按 25% CPU 利用率计算正式工和小时工数值。

```go
// mgc.go

const gcBackgroundUtilization = 0.25
```

```go
// mgc.go

// startCycle resets the GC controller's state and computes estimates
// for a new GC cycle. 

func (c *gcControllerState) startCycle(markStartTime int64, procs int) {
    
    // 确保目标比 heapLive 大一点。
    if goexperiment.PacerRedesign {
        if c.heapGoal < c.heapLive+64<<10 {
            c.heapGoal = c.heapLive + 64<<10
        }
    } else {
        if c.heapGoal < c.heapLive+1<<20 {
            c.heapGoal = c.heapLive + 1<<20
        }
    }

    // CPU 利用率（25%）。
    totalUtilizationGoal := float64(procs) * gcBackgroundUtilization    

    // 职业工（dedicated）取整，小数为小时工（fractional）。
    c.dedicatedMarkWorkersNeeded = int64(totalUtilizationGoal + 0.5)
    utilError := float64(c.dedicatedMarkWorkersNeeded)/totalUtilizationGoal - 1
    const maxUtilError = 0.3
    if utilError < -maxUtilError || utilError > maxUtilError {
        if float64(c.dedicatedMarkWorkersNeeded) > totalUtilizationGoal {
            // Too many dedicated workers.
            c.dedicatedMarkWorkersNeeded--
        }
        c.fractionalUtilizationGoal = (totalUtilizationGoal - float64(c.dedicatedMarkWorkersNeeded)) / float64(procs)
    } else {
        c.fractionalUtilizationGoal = 0
    }
    
    // 当 GODEBUG=gcstoptheword 关闭并发，全部成为正式工。
    if debug.gcstoptheworld > 0 {
        c.dedicatedMarkWorkersNeeded = int64(procs)
        c.fractionalUtilizationGoal = 0
    }
    
    // 清除所有 P 相关状态。
    for _, p := range allp {
        p.gcAssistTime = 0
        p.gcFractionalMarkTime = 0
    }
    
    // 计算辅助回收比率。
    c.revise()
}
```

随后，解除STW，让MP重回调度循环(schedule)。在这里，检查垃圾回收状态，按需激活 worker.G 开始垃圾标记工作。

```go
// proc.go

func schedule() {
    if gp == nil && gcBlackenEnabled != 0 {
        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
    }    
    
    execute(gp, inheritTime)
}
```

```go
// mgcpacer.go

// findRunnableGCWorker returns a background mark worker for _p_ if it
// should be run. This must only be called when gcBlackenEnabled != 0.

func (c *gcControllerState) findRunnableGCWorker(_p_ *p) *g {

    // 检查任务队列。
    // 刚启动时，gcMarkRootPrepare 准备了 work.markrootJobs 任务。
    if !gcMarkWorkAvailable(_p_) {
        return nil
    }

    // 取一个预先创建的 worker G。
    node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())
    if node == nil {
        return nil
    }

    // 减法（lock-free）。
    decIfPositive := func(ptr *int64) bool {
        for {
            v := atomic.Loadint64(ptr)
            if v <= 0 {
                return false
            }

            if atomic.Casint64(ptr, v, v-1) {
                return true
            }
        }
    }

    // 消费工人名额，设置 P.worker 工种。
    if decIfPositive(&c.dedicatedMarkWorkersNeeded) {

        // This P is now dedicated to marking until the end of
        // the concurrent mark phase.
        _p_.gcMarkWorkerMode = gcMarkWorkerDedicatedMode

    } else if c.fractionalUtilizationGoal == 0 {

        // No need for fractional workers.
        gcBgMarkWorkerPool.push(&node.node)

        return nil
    } else {

        // Is this P behind on the fractional utilization goal?
        delta := nanotime() - c.markStartTime
        if delta > 0 && float64(_p_.gcFractionalMarkTime)/float64(delta) > c.fractionalUtilizationGoal {
            // Nope. No need to run a fractional worker.
            gcBgMarkWorkerPool.push(&node.node)
            return nil
        }

        // Run a fractional worker.
        _p_.gcMarkWorkerMode = gcMarkWorkerFractionalMode
    }

    // 修改 worker.G 状态，并返回。
    gp := node.gp.ptr()
    casgstatus(gp, _Gwaiting, _Grunnable)
    
    return gp
}
```

其他MP调度不到任务时，也尝试以临时工(idle)身份参与工作。

```go
// proc.go

func findrunnable() (gp *g, inheritTime bool) {
    
    // We have nothing to do.
    //
    // If we're in the GC mark phase, can safely scan and blacken objects,
    // and have work to do, run idle-time marking rather than give up the
    // P.
    
    if gcBlackenEnabled != 0 && gcMarkWorkAvailable(_p_) {
        node := (*gcBgMarkWorkerNode)(gcBgMarkWorkerPool.pop())
        if node != nil {
            _p_.gcMarkWorkerMode = gcMarkWorkerIdleMode
            gp := node.gp.ptr()
            casgstatus(gp, _Gwaiting, _Grunnable)

            return gp, false
        }
    }    
}
```
