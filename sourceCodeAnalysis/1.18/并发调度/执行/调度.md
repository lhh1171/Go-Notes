# 调度

调度函数除在各级队列查找任务外，还要处理垃圾回收、锁定等情况。



```go
// proc.go

// One round of scheduler: find a runnable goroutine and execute it.
// Never returns.

func schedule() {
    _g_ := getg()
    
    // 检查当前 M 是否被特定 G 锁定。
    // 交出 P，休眠 M，直到其他人发现锁定任务后唤醒执行。    
    if _g_.m.lockedg != 0 {
        // 将当前的 M 和 P 解绑
        stoplockedm()
        execute(_g_.m.lockedg.ptr(), false) // Never returns.
    }
    
top:
    
    pp := _g_.m.p.ptr()
    pp.preempt = false      // 设置抢占位；不抢占
    
    // GC等待被执行
    // STW 标记。
    if sched.gcwaiting != 0 {
        gcstopm()
        goto top
    }
    
    // 执行安全函数，比如 forEachP。
    if pp.runSafePointFn != 0 {
        runSafePointFn()
    }

    // 检查并执行定时器。
    checkTimers(pp, 0)
    
    var gp *g
    var inheritTime bool

    // 启动垃圾回收任务。
    if gp == nil && gcBlackenEnabled != 0 {
        gp = gcController.findRunnableGCWorker(_g_.m.p.ptr())
        if gp != nil {
            tryWakeP = true
        }
    }
    
    // 每隔 60 次，尝试从全局队列提取任务，以确保公平。
    if gp == nil {
        
        // Check the global runnable queue once in a while to ensure fairness.
        // Otherwise two goroutines can completely occupy the local runqueue
        // by constantly respawning each other.
        
        if _g_.m.p.ptr().schedtick%61 == 0 && sched.runqsize > 0 {
            lock(&sched.lock)
            gp = globrunqget(_g_.m.p.ptr(), 1)
            unlock(&sched.lock)
        }
    }
    
    // 从本地任务队列提取。
    if gp == nil {
        gp, inheritTime = runqget(_g_.m.p.ptr())
        // We can see gp != nil here even if the M is spinning,
        // if checkTimers added a local goroutine via goready.
    }
    
    // 从其他可能的地方提取。
    if gp == nil {
        gp, inheritTime = findrunnable() // blocks until work is available
    }
    
    // 找到任务，解除自旋状态。
    if _g_.m.spinning {
        resetspinning()
    }

    // 找到锁定任务，移交 P 给锁定 M 去执行。
    // 自己休眠。一旦被唤醒，则重新开始调度循环。
    if gp.lockedm != 0 {
        
        // Hands off own p to the locked m,
        // then blocks waiting for a new p.
        startlockedm(gp)
        
        goto top
    }
    
    // 执行任务。
    execute(gp, inheritTime)
}
```

如果返回的是`runnext`，则 `inheritTime = True`。表示继承上个任务时间片，不累加执行计数器(`P.schedtick`)，这会减少对全局队列的检查。

另一方面，`sysmon` 会比对不同时段计数器，检查是否执行了新任务。以此判断任务执行时间是否超长(10ms)，是否需要抢占调度。

> 在 `GODEBUG=scheddetail=1,schedtrace=1000` 输出里可以看到计数器信息

单个`G`未必在一次调度内结束，因某些原因中断，被重新放回任务队列，等待断点恢复。

> MP 切换任务前，会将执行状态(`PC、SP`)保存到`G.sched`，其他寄存器数据保存到`G.stack`。切换本身(G100->G0->G101)，消耗并不大，关键在于如何查找下一个G任务。

* 阻塞：`block`、`syscall`、`mutex`、`channel`。
* 抢占：`preempt`、`sysmon`。
