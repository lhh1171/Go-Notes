# 内核调用

运行时(runtime)不能使用用户栈(`G.stack`)，须切回到`M.g0`。为此用汇编实现了专门的调用函数。

> 有关汇编相关内容，参考《语言规范，进阶-混合编程》。
>
> 正常情况下，不会调整`g0.sched`设置。保持`mstart1`设置的初始化状态。以此开始执行，复用栈内存。
>
> 因此，每次切换到`g0`都从第二栈帧开始，无须清理调用堆栈。一旦出错，就回到`mstart0`内调用`mexit`终止。

&nbsp;

## mcall

保存当前G执行状态，切换到g0执行特定函数。由于函数不返回，所以`mcall`不负责切回G。

```nasm
// asm_amd64.s

// func mcall(fn func(*g))
// Switch to m->g0's stack, call fn(g).

// Fn must never return. It should gogo(&g->sched)
// to keep running g.

TEXT runtime·mcall<ABIInternal>(SB), NOSPLIT, $0-8
    
    // 参数
    MOVQ    AX, DX                              // DX = fn

    // 保存状态（g.sched）。
    // g状态保存到g.sched
    MOVQ    0(SP), BX
    MOVQ    BX, (g_sched+gobuf_pc)(R14)         // BX ==> g.sched.pc
    LEAQ    fn+0(FP), BX                        // g.sp ==> BX
    MOVQ    BX, (g_sched+gobuf_sp)(R14)         // BX ==> g.sp ==> save ==> g.sched.sp
    MOVQ    BP, (g_sched+gobuf_bp)(R14)         // BP ==> g.bp ==> save ==> g.sched.bp

    MOVQ    g_m(R14), BX                        // BX = g.m
    MOVQ    m_g0(BX), SI                        // SI = g.m.g0  ==> G0
    
    CMPQ    SI, R14                             // if g == m->g0 call badmcall  // SI ==> G0  R14 ==> g
    JNE     goodm
    JMP     runtime·badmcall(SB)
    
    goodm:

    // 保存当前 g，作为后续调用参数。
    MOVQ    R14, AX                            // AX (and arg 0) = g; g保存到AX
    MOVQ    SI, R14                            // g.m.g0  ==> R14 ==> G0

    // 恢复 g0 栈。
    get_tls(CX)                                // MOVQ (TLS), CX                    // Set G in TLS, 
    MOVQ    R14, g(CX)                         // MOVQ R14(G0) 0(CX)(TLS*1)
    MOVQ    (g_sched+gobuf_sp)(R14), SP        // sp = g0.sched.sp
    
    // 调用目标函数。
    PUSHQ   AX                                  // fn.arg = g; 将g状态AX保存到stack
    MOVQ    0(DX), R12                          // [DX] ==> 待执行的特殊函数
    CALL    R12              // fn(g            // G0执行特定函数
    
    POPQ    AX
    JMP     runtime·badmcall2(SB)
    RET
```

> 提示：`get_tls`将G指针存入指定寄存器。
