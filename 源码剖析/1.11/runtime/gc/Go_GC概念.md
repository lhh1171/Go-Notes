# Go gc(Garbage collector)

## 概念
GC与mutator线程并行运行,允许多个GC线程并行运行。它是一个使用写屏障的并发标记和扫描。它是非代数和非紧凑的。使用按P分配区域隔离的大小完成分配,以最小化碎片,同时消除常见情况下锁定。


### Mutator
在GC的过程中同时运行的G称为mutator,mutator assist机制就是G辅助GC做一一部分工作的机制。
Mutator 做的工作有两种类型: 

* 标记(mark)
* 清除(Sweep)

### 写屏障(Write barrier)
写屏障主要处理扫描过的对象的状态变化,使用写屏障技术监控这段对象的内存,当对象状态发生改变时,写屏障会发送一个信号,GC会捕获到写屏障的信号。GC就可以知道这个对象发生了改变,则GC会重新扫描这个对象,进行状态重置。进行判断这个状态是否存活。

### 根对象(Root)
生命周期可以保证的对象.比如,线程栈(stack内引用的指针)、全局变量等。

### STW优化
在清理阶段GC可以和用户线程并发执行,因为回收的是那些标记为白色没有被引用的对象(不会被线程栈、全局变量引用)。清理操作可以被并发,进而缩短STW时间。

扫描阶段通过写屏障技术可以在一定程度上减少STW时间。


## 三色清理标记原理概述
* 起初所有对象都是白色。
* 扫描所有可达对象,标记为灰色,放入待处理队列。
* 从队列提取灰色对象,将其引用对象标记为灰色放入待处理队列,将自己标记为黑色放入队列。
* 写屏障监控对象内存修改,从新标色或放入队列。

当完成所有的扫描和标记的工作后,剩下不是白色就是黑色。分别代表要回收和活跃对象,清理操作只需要把白色对象回收。

### 三色清理标记算法详细步骤

![gc三色标记](./gc.png)

#### GC清除终止 

* Stop the world(STW),所有线程停止运行,所有P处于GC安全点。
* 清理所有未清理的spans,如果在预期时间之前强制执行GC循环,则仅清理未清理的spans。

#### 标记阶段(第一阶段)
* 准备标记阶段(通过gcphase设置为_GCmark)。启动写屏障,启用mutator assist,并对根对象放入队列, 准备标记。(在所有P启动写屏障之前,不会扫描任何对象,这是使用STW完成的)
* Start the world,从现在开始,GC的标记和分配的一部分执行辅助工作完成。写屏障将覆盖指针和新指针着色,新分配的对象会被标记为黑色。
* GC执行根标记, 扫描所有stacks。着色所有全局变量以及堆外runtime数据结构中的任何堆指针。扫描stack时会停止当前goroutine,着色在当前stack扫描到的任何指针,然后恢复goroutine 运行。
* 从队列提出灰色对象,将其引用对象标记为灰色放入待处理队列,将自己标记为黑色放入队列。

#### 标记阶段(第二阶段) - Central cache为空,但Mcache不为空
* GC停止所有Worker,禁用本地工作队列缓存(mcache),将每个P的mcache缓存刷新到全局队列缓存(Central cache),并重新启用工作程序。
* GC再次放入队列,等待被调度(第一标记阶段)。

#### 工作队列为空后,GC标记终止
* Stop the world(stw)。
* 将gcphase设置为_GCmarktermination,禁止工作和mutator assist。
* 从工作队列中获取剩余的工作(通常没有)。
* 执行其它内务工作,如清理mcaches。

#### GC清除阶段
* 将gcphase设置为_GCoff,设置清除状态并禁用写屏障。准备进行清除阶段。
* Start the world。从现在开始,新分配对象为白色,并在必要时在使用前分配扫描范围。
* GC在后台进行并发清除并进行内存分配。


#### GC触发
 * 当分配了足够内存堆内存空间时,重新从步骤1开始执行。
 

#### 标记过程实例

![标记过程](./gc1.png)

还有一种情况,标记过程中,heap上的object被赋值给了一个栈上指针,导致这个object没有被标记到。因为对stack指针进行写入,写屏障检测不到。下图展示了整个流程(其中 L 是栈上指针):
![标记过程](./gc2.png)

为了解决这个问题，标记的最后阶段，还会回头重新扫描一下所有的栈空间，确保没有遗漏。而这个过程就需要启动 STW 了，否则并发场景会使上述场景反复重现。

##### Hibrid Write Barrier
三色标记方式，需要在最后重新扫描一下所有全局变量和goroutine栈空间，如果系统的goroutine很多，这个阶段耗时也会比较长，甚至会长达 100ms。毕竟Goroutine很轻量，大型系统中，上百万的Goroutine也是常有的事儿。

上面说对栈上指针进行写入，写屏障是检测不到，实际上并不是做不到，而是代价非常高，Go的写屏障故意没去管它，而是采取了再次扫描的方案。

Go1.8版本引入了混合写屏障,会在赋值前,对旧数据置灰,再视情况对新值进行置灰。

![标记过程](./gc3.png)

混合写屏障会有一点小小的代价，就是上例中如果C没有赋值给L，用户执行B.next = nil后，C 的的确确变成了垃圾，而我们却把置灰了，使得C 只能等到下一轮GC才能被回收了。

GC过程创建的新对象直接标记成黑色也会带来这个问题，即使新object在扫描结束前变成了垃圾，这次GC也不会回收它，只能等下轮。


## 并发清理

* 清理阶段与正常程序同时执行。当涉及到跨多个span(当goroutine需要另一个span时)并且同时在后端goroutine中扫描(这有助于不受cpu限制)。在STW标记终止结束时,所有spans都标记为"需要清理"。
* 背景清除goroutine串行一个接一个地清除span。
* 为了避免在有未清理spans的情况下请求更多的操作系统内存,当goroutine需要另一个span时,它首先尝试通过清理来回收更多内存进行复用。当goroutine需要分配一个小对象span时,它会清理相同对象大小的span,直到它释放一个对象。当goroutine需要从堆中分配大对象span时,它会清理span,直到它将至少那么多页释放到堆中。有一种情况,可能不能够使用: 如果goroutine清除并释放两个不相邻的单页span到堆。它将分配一个新的两页span,但仍然可以有其它单页未清除span,可能是合并为两页span。
* 确保在未清除的span上不进行任何操作(这会破坏GC位图中的标记位)至关重要。在GC期间,所有mcache都被刷新到Central cache,因此它们是空的。当goroutine获取了一个新的span到mcache时,GC会扫描它。当goroutine显示释放对象或设置终结器时,它确保是被清除的span(通过清除它,或等待并发清除完成)。只有当所有span都被清理过时,终结器goroutine才会被踢掉。当下一个GC开始时,它清除所有尚未清除的span。


## 何时触发GC
一般是当Heap上的内存达到一定数值后，会触发一次GC，这个数值我们可以通过环境变量GOGC或者debug.SetGCPercent()设置，默认是100，表示当内存增长100%执行一次GC。如果当前堆内存使用了10MB，那么等到它涨到200MB的时候就会触发GC。

再就是每隔2分钟，如果期间内没有触发GC，也会强制触发一次。

最后就是用户手动触发了，也就是调用runtime.GC()强制触发一次。


## Oblets
为了防止在扫描大对象时出现长时间暂停并提高并行性,垃圾收集器将大于maxObletBytes的对象的扫描分解为最多maxobletBytes的"oblets"。当扫描遇到大对象时,它只扫描第一个oblet并将剩余的oblet列为新的扫描任务。

### Oblets 来源
oblets是Tcl语言的一个非常简单的对象系统,对象数据存储在全局数组中。














